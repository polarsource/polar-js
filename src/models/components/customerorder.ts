/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as types from "../../types/primitives.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import { Address, Address$inboundSchema } from "./address.js";
import {
  CustomerOrderProduct,
  CustomerOrderProduct$inboundSchema,
} from "./customerorderproduct.js";
import {
  CustomerOrderSubscription,
  CustomerOrderSubscription$inboundSchema,
} from "./customerordersubscription.js";
import {
  OrderBillingReason,
  OrderBillingReason$inboundSchema,
} from "./orderbillingreason.js";
import {
  OrderItemSchema,
  OrderItemSchema$inboundSchema,
} from "./orderitemschema.js";
import { OrderStatus, OrderStatus$inboundSchema } from "./orderstatus.js";

export type CustomerOrder = {
  /**
   * The ID of the object.
   */
  id: string;
  /**
   * Creation timestamp of the object.
   */
  createdAt: Date;
  /**
   * Last modification timestamp of the object.
   */
  modifiedAt: Date | null;
  status: OrderStatus;
  /**
   * Whether the order has been paid for.
   */
  paid: boolean;
  /**
   * Amount in cents, before discounts and taxes.
   */
  subtotalAmount: number;
  /**
   * Discount amount in cents.
   */
  discountAmount: number;
  /**
   * Amount in cents, after discounts but before taxes.
   */
  netAmount: number;
  /**
   * Sales tax amount in cents.
   */
  taxAmount: number;
  /**
   * Amount in cents, after discounts and taxes.
   */
  totalAmount: number;
  /**
   * Customer's balance amount applied to this invoice. Can increase the total amount paid, if the customer has a negative balance,  or decrease it, if the customer has a positive balance.Amount in cents.
   */
  appliedBalanceAmount: number;
  /**
   * Amount in cents that is due for this order.
   */
  dueAmount: number;
  /**
   * Amount refunded in cents.
   */
  refundedAmount: number;
  /**
   * Sales tax refunded in cents.
   */
  refundedTaxAmount: number;
  currency: string;
  billingReason: OrderBillingReason;
  /**
   * The name of the customer that should appear on the invoice.
   */
  billingName: string | null;
  billingAddress: Address | null;
  /**
   * The invoice number associated with this order.
   */
  invoiceNumber: string;
  /**
   * Whether an invoice has been generated for this order.
   */
  isInvoiceGenerated: boolean;
  /**
   * Number of seats purchased (for seat-based one-time orders).
   */
  seats?: number | null | undefined;
  customerId: string;
  productId: string | null;
  discountId: string | null;
  subscriptionId: string | null;
  checkoutId: string | null;
  /**
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  userId: string;
  product: CustomerOrderProduct | null;
  subscription: CustomerOrderSubscription | null;
  /**
   * Line items composing the order.
   */
  items: Array<OrderItemSchema>;
  /**
   * A summary description of the order.
   */
  description: string;
  /**
   * When the next payment retry is scheduled
   */
  nextPaymentAttemptAt?: Date | null | undefined;
};

/** @internal */
export const CustomerOrder$inboundSchema: z.ZodMiniType<
  CustomerOrder,
  unknown
> = z.pipe(
  z.object({
    id: types.string(),
    created_at: types.date(),
    modified_at: types.nullable(types.date()),
    status: OrderStatus$inboundSchema,
    paid: types.boolean(),
    subtotal_amount: types.number(),
    discount_amount: types.number(),
    net_amount: types.number(),
    tax_amount: types.number(),
    total_amount: types.number(),
    applied_balance_amount: types.number(),
    due_amount: types.number(),
    refunded_amount: types.number(),
    refunded_tax_amount: types.number(),
    currency: types.string(),
    billing_reason: OrderBillingReason$inboundSchema,
    billing_name: types.nullable(types.string()),
    billing_address: types.nullable(Address$inboundSchema),
    invoice_number: types.string(),
    is_invoice_generated: types.boolean(),
    seats: z.optional(z.nullable(types.number())),
    customer_id: types.string(),
    product_id: types.nullable(types.string()),
    discount_id: types.nullable(types.string()),
    subscription_id: types.nullable(types.string()),
    checkout_id: types.nullable(types.string()),
    user_id: types.string(),
    product: types.nullable(CustomerOrderProduct$inboundSchema),
    subscription: types.nullable(CustomerOrderSubscription$inboundSchema),
    items: z.array(OrderItemSchema$inboundSchema),
    description: types.string(),
    next_payment_attempt_at: z.optional(z.nullable(types.date())),
  }),
  z.transform((v) => {
    return remap$(v, {
      "created_at": "createdAt",
      "modified_at": "modifiedAt",
      "subtotal_amount": "subtotalAmount",
      "discount_amount": "discountAmount",
      "net_amount": "netAmount",
      "tax_amount": "taxAmount",
      "total_amount": "totalAmount",
      "applied_balance_amount": "appliedBalanceAmount",
      "due_amount": "dueAmount",
      "refunded_amount": "refundedAmount",
      "refunded_tax_amount": "refundedTaxAmount",
      "billing_reason": "billingReason",
      "billing_name": "billingName",
      "billing_address": "billingAddress",
      "invoice_number": "invoiceNumber",
      "is_invoice_generated": "isInvoiceGenerated",
      "customer_id": "customerId",
      "product_id": "productId",
      "discount_id": "discountId",
      "subscription_id": "subscriptionId",
      "checkout_id": "checkoutId",
      "user_id": "userId",
      "next_payment_attempt_at": "nextPaymentAttemptAt",
    });
  }),
);

export function customerOrderFromJSON(
  jsonString: string,
): SafeParseResult<CustomerOrder, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CustomerOrder$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CustomerOrder' from JSON`,
  );
}
