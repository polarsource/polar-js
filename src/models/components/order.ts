/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as types from "../../types/primitives.js";
import { smartUnion } from "../../types/smartUnion.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import {
  Address,
  Address$inboundSchema,
  Address$Outbound,
  Address$outboundSchema,
} from "./address.js";
import {
  DiscountFixedOnceForeverDurationBase,
  DiscountFixedOnceForeverDurationBase$inboundSchema,
  DiscountFixedOnceForeverDurationBase$Outbound,
  DiscountFixedOnceForeverDurationBase$outboundSchema,
} from "./discountfixedonceforeverdurationbase.js";
import {
  DiscountFixedRepeatDurationBase,
  DiscountFixedRepeatDurationBase$inboundSchema,
  DiscountFixedRepeatDurationBase$Outbound,
  DiscountFixedRepeatDurationBase$outboundSchema,
} from "./discountfixedrepeatdurationbase.js";
import {
  DiscountPercentageOnceForeverDurationBase,
  DiscountPercentageOnceForeverDurationBase$inboundSchema,
  DiscountPercentageOnceForeverDurationBase$Outbound,
  DiscountPercentageOnceForeverDurationBase$outboundSchema,
} from "./discountpercentageonceforeverdurationbase.js";
import {
  DiscountPercentageRepeatDurationBase,
  DiscountPercentageRepeatDurationBase$inboundSchema,
  DiscountPercentageRepeatDurationBase$Outbound,
  DiscountPercentageRepeatDurationBase$outboundSchema,
} from "./discountpercentagerepeatdurationbase.js";
import {
  MetadataOutputType,
  MetadataOutputType$inboundSchema,
  MetadataOutputType$Outbound,
  MetadataOutputType$outboundSchema,
} from "./metadataoutputtype.js";
import {
  OrderBillingReason,
  OrderBillingReason$inboundSchema,
  OrderBillingReason$outboundSchema,
} from "./orderbillingreason.js";
import {
  OrderCustomer,
  OrderCustomer$inboundSchema,
  OrderCustomer$Outbound,
  OrderCustomer$outboundSchema,
} from "./ordercustomer.js";
import {
  OrderItemSchema,
  OrderItemSchema$inboundSchema,
  OrderItemSchema$Outbound,
  OrderItemSchema$outboundSchema,
} from "./orderitemschema.js";
import {
  OrderProduct,
  OrderProduct$inboundSchema,
  OrderProduct$Outbound,
  OrderProduct$outboundSchema,
} from "./orderproduct.js";
import {
  OrderStatus,
  OrderStatus$inboundSchema,
  OrderStatus$outboundSchema,
} from "./orderstatus.js";
import {
  OrderSubscription,
  OrderSubscription$inboundSchema,
  OrderSubscription$Outbound,
  OrderSubscription$outboundSchema,
} from "./ordersubscription.js";

export type OrderCustomFieldData = string | number | boolean | Date;

export type OrderDiscount =
  | DiscountFixedRepeatDurationBase
  | DiscountFixedOnceForeverDurationBase
  | DiscountPercentageRepeatDurationBase
  | DiscountPercentageOnceForeverDurationBase;

export type Order = {
  /**
   * The ID of the object.
   */
  id: string;
  /**
   * Creation timestamp of the object.
   */
  createdAt: Date;
  /**
   * Last modification timestamp of the object.
   */
  modifiedAt: Date | null;
  status: OrderStatus;
  /**
   * Whether the order has been paid for.
   */
  paid: boolean;
  /**
   * Amount in cents, before discounts and taxes.
   */
  subtotalAmount: number;
  /**
   * Discount amount in cents.
   */
  discountAmount: number;
  /**
   * Amount in cents, after discounts but before taxes.
   */
  netAmount: number;
  /**
   * Sales tax amount in cents.
   */
  taxAmount: number;
  /**
   * Amount in cents, after discounts and taxes.
   */
  totalAmount: number;
  /**
   * Customer's balance amount applied to this invoice. Can increase the total amount paid, if the customer has a negative balance,  or decrease it, if the customer has a positive balance.Amount in cents.
   */
  appliedBalanceAmount: number;
  /**
   * Amount in cents that is due for this order.
   */
  dueAmount: number;
  /**
   * Amount refunded in cents.
   */
  refundedAmount: number;
  /**
   * Sales tax refunded in cents.
   */
  refundedTaxAmount: number;
  currency: string;
  billingReason: OrderBillingReason;
  /**
   * The name of the customer that should appear on the invoice.
   */
  billingName: string | null;
  billingAddress: Address | null;
  /**
   * The invoice number associated with this order.
   */
  invoiceNumber: string;
  /**
   * Whether an invoice has been generated for this order.
   */
  isInvoiceGenerated: boolean;
  /**
   * Number of seats purchased (for seat-based one-time orders).
   */
  seats?: number | null | undefined;
  customerId: string;
  productId: string | null;
  discountId: string | null;
  subscriptionId: string | null;
  checkoutId: string | null;
  metadata: { [k: string]: MetadataOutputType };
  /**
   * Key-value object storing custom field values.
   */
  customFieldData?:
    | { [k: string]: string | number | boolean | Date | null }
    | undefined;
  /**
   * Platform fee amount in cents.
   */
  platformFeeAmount: number;
  /**
   * Currency of the platform fee.
   */
  platformFeeCurrency: string | null;
  customer: OrderCustomer;
  /**
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  userId: string;
  product: OrderProduct | null;
  discount:
    | DiscountFixedRepeatDurationBase
    | DiscountFixedOnceForeverDurationBase
    | DiscountPercentageRepeatDurationBase
    | DiscountPercentageOnceForeverDurationBase
    | null;
  subscription: OrderSubscription | null;
  /**
   * Line items composing the order.
   */
  items: Array<OrderItemSchema>;
  /**
   * A summary description of the order.
   */
  description: string;
};

/** @internal */
export const OrderCustomFieldData$inboundSchema: z.ZodMiniType<
  OrderCustomFieldData,
  unknown
> = smartUnion([types.string(), types.number(), types.boolean(), types.date()]);
/** @internal */
export type OrderCustomFieldData$Outbound = string | number | boolean | string;

/** @internal */
export const OrderCustomFieldData$outboundSchema: z.ZodMiniType<
  OrderCustomFieldData$Outbound,
  OrderCustomFieldData
> = smartUnion([
  z.string(),
  z.int(),
  z.boolean(),
  z.pipe(z.date(), z.transform(v => v.toISOString())),
]);

export function orderCustomFieldDataToJSON(
  orderCustomFieldData: OrderCustomFieldData,
): string {
  return JSON.stringify(
    OrderCustomFieldData$outboundSchema.parse(orderCustomFieldData),
  );
}
export function orderCustomFieldDataFromJSON(
  jsonString: string,
): SafeParseResult<OrderCustomFieldData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrderCustomFieldData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrderCustomFieldData' from JSON`,
  );
}

/** @internal */
export const OrderDiscount$inboundSchema: z.ZodMiniType<
  OrderDiscount,
  unknown
> = smartUnion([
  DiscountFixedRepeatDurationBase$inboundSchema,
  DiscountFixedOnceForeverDurationBase$inboundSchema,
  DiscountPercentageRepeatDurationBase$inboundSchema,
  DiscountPercentageOnceForeverDurationBase$inboundSchema,
]);
/** @internal */
export type OrderDiscount$Outbound =
  | DiscountFixedRepeatDurationBase$Outbound
  | DiscountFixedOnceForeverDurationBase$Outbound
  | DiscountPercentageRepeatDurationBase$Outbound
  | DiscountPercentageOnceForeverDurationBase$Outbound;

/** @internal */
export const OrderDiscount$outboundSchema: z.ZodMiniType<
  OrderDiscount$Outbound,
  OrderDiscount
> = smartUnion([
  DiscountFixedRepeatDurationBase$outboundSchema,
  DiscountFixedOnceForeverDurationBase$outboundSchema,
  DiscountPercentageRepeatDurationBase$outboundSchema,
  DiscountPercentageOnceForeverDurationBase$outboundSchema,
]);

export function orderDiscountToJSON(orderDiscount: OrderDiscount): string {
  return JSON.stringify(OrderDiscount$outboundSchema.parse(orderDiscount));
}
export function orderDiscountFromJSON(
  jsonString: string,
): SafeParseResult<OrderDiscount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrderDiscount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrderDiscount' from JSON`,
  );
}

/** @internal */
export const Order$inboundSchema: z.ZodMiniType<Order, unknown> = z.pipe(
  z.object({
    id: types.string(),
    created_at: types.date(),
    modified_at: types.nullable(types.date()),
    status: OrderStatus$inboundSchema,
    paid: types.boolean(),
    subtotal_amount: types.number(),
    discount_amount: types.number(),
    net_amount: types.number(),
    tax_amount: types.number(),
    total_amount: types.number(),
    applied_balance_amount: types.number(),
    due_amount: types.number(),
    refunded_amount: types.number(),
    refunded_tax_amount: types.number(),
    currency: types.string(),
    billing_reason: OrderBillingReason$inboundSchema,
    billing_name: types.nullable(types.string()),
    billing_address: types.nullable(Address$inboundSchema),
    invoice_number: types.string(),
    is_invoice_generated: types.boolean(),
    seats: z.optional(z.nullable(types.number())),
    customer_id: types.string(),
    product_id: types.nullable(types.string()),
    discount_id: types.nullable(types.string()),
    subscription_id: types.nullable(types.string()),
    checkout_id: types.nullable(types.string()),
    metadata: z.record(z.string(), MetadataOutputType$inboundSchema),
    custom_field_data: types.optional(
      z.record(
        z.string(),
        types.nullable(
          smartUnion([
            types.string(),
            types.number(),
            types.boolean(),
            types.date(),
          ]),
        ),
      ),
    ),
    platform_fee_amount: types.number(),
    platform_fee_currency: types.nullable(types.string()),
    customer: OrderCustomer$inboundSchema,
    user_id: types.string(),
    product: types.nullable(OrderProduct$inboundSchema),
    discount: types.nullable(
      smartUnion([
        DiscountFixedRepeatDurationBase$inboundSchema,
        DiscountFixedOnceForeverDurationBase$inboundSchema,
        DiscountPercentageRepeatDurationBase$inboundSchema,
        DiscountPercentageOnceForeverDurationBase$inboundSchema,
      ]),
    ),
    subscription: types.nullable(OrderSubscription$inboundSchema),
    items: z.array(OrderItemSchema$inboundSchema),
    description: types.string(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "created_at": "createdAt",
      "modified_at": "modifiedAt",
      "subtotal_amount": "subtotalAmount",
      "discount_amount": "discountAmount",
      "net_amount": "netAmount",
      "tax_amount": "taxAmount",
      "total_amount": "totalAmount",
      "applied_balance_amount": "appliedBalanceAmount",
      "due_amount": "dueAmount",
      "refunded_amount": "refundedAmount",
      "refunded_tax_amount": "refundedTaxAmount",
      "billing_reason": "billingReason",
      "billing_name": "billingName",
      "billing_address": "billingAddress",
      "invoice_number": "invoiceNumber",
      "is_invoice_generated": "isInvoiceGenerated",
      "customer_id": "customerId",
      "product_id": "productId",
      "discount_id": "discountId",
      "subscription_id": "subscriptionId",
      "checkout_id": "checkoutId",
      "custom_field_data": "customFieldData",
      "platform_fee_amount": "platformFeeAmount",
      "platform_fee_currency": "platformFeeCurrency",
      "user_id": "userId",
    });
  }),
);
/** @internal */
export type Order$Outbound = {
  id: string;
  created_at: string;
  modified_at: string | null;
  status: string;
  paid: boolean;
  subtotal_amount: number;
  discount_amount: number;
  net_amount: number;
  tax_amount: number;
  total_amount: number;
  applied_balance_amount: number;
  due_amount: number;
  refunded_amount: number;
  refunded_tax_amount: number;
  currency: string;
  billing_reason: string;
  billing_name: string | null;
  billing_address: Address$Outbound | null;
  invoice_number: string;
  is_invoice_generated: boolean;
  seats?: number | null | undefined;
  customer_id: string;
  product_id: string | null;
  discount_id: string | null;
  subscription_id: string | null;
  checkout_id: string | null;
  metadata: { [k: string]: MetadataOutputType$Outbound };
  custom_field_data?:
    | { [k: string]: string | number | boolean | string | null }
    | undefined;
  platform_fee_amount: number;
  platform_fee_currency: string | null;
  customer: OrderCustomer$Outbound;
  user_id: string;
  product: OrderProduct$Outbound | null;
  discount:
    | DiscountFixedRepeatDurationBase$Outbound
    | DiscountFixedOnceForeverDurationBase$Outbound
    | DiscountPercentageRepeatDurationBase$Outbound
    | DiscountPercentageOnceForeverDurationBase$Outbound
    | null;
  subscription: OrderSubscription$Outbound | null;
  items: Array<OrderItemSchema$Outbound>;
  description: string;
};

/** @internal */
export const Order$outboundSchema: z.ZodMiniType<Order$Outbound, Order> = z
  .pipe(
    z.object({
      id: z.string(),
      createdAt: z.pipe(z.date(), z.transform(v => v.toISOString())),
      modifiedAt: z.nullable(
        z.pipe(z.date(), z.transform(v => v.toISOString())),
      ),
      status: OrderStatus$outboundSchema,
      paid: z.boolean(),
      subtotalAmount: z.int(),
      discountAmount: z.int(),
      netAmount: z.int(),
      taxAmount: z.int(),
      totalAmount: z.int(),
      appliedBalanceAmount: z.int(),
      dueAmount: z.int(),
      refundedAmount: z.int(),
      refundedTaxAmount: z.int(),
      currency: z.string(),
      billingReason: OrderBillingReason$outboundSchema,
      billingName: z.nullable(z.string()),
      billingAddress: z.nullable(Address$outboundSchema),
      invoiceNumber: z.string(),
      isInvoiceGenerated: z.boolean(),
      seats: z.optional(z.nullable(z.int())),
      customerId: z.string(),
      productId: z.nullable(z.string()),
      discountId: z.nullable(z.string()),
      subscriptionId: z.nullable(z.string()),
      checkoutId: z.nullable(z.string()),
      metadata: z.record(z.string(), MetadataOutputType$outboundSchema),
      customFieldData: z.optional(
        z.record(
          z.string(),
          z.nullable(
            smartUnion([
              z.string(),
              z.int(),
              z.boolean(),
              z.pipe(z.date(), z.transform(v => v.toISOString())),
            ]),
          ),
        ),
      ),
      platformFeeAmount: z.int(),
      platformFeeCurrency: z.nullable(z.string()),
      customer: OrderCustomer$outboundSchema,
      userId: z.string(),
      product: z.nullable(OrderProduct$outboundSchema),
      discount: z.nullable(
        smartUnion([
          DiscountFixedRepeatDurationBase$outboundSchema,
          DiscountFixedOnceForeverDurationBase$outboundSchema,
          DiscountPercentageRepeatDurationBase$outboundSchema,
          DiscountPercentageOnceForeverDurationBase$outboundSchema,
        ]),
      ),
      subscription: z.nullable(OrderSubscription$outboundSchema),
      items: z.array(OrderItemSchema$outboundSchema),
      description: z.string(),
    }),
    z.transform((v) => {
      return remap$(v, {
        createdAt: "created_at",
        modifiedAt: "modified_at",
        subtotalAmount: "subtotal_amount",
        discountAmount: "discount_amount",
        netAmount: "net_amount",
        taxAmount: "tax_amount",
        totalAmount: "total_amount",
        appliedBalanceAmount: "applied_balance_amount",
        dueAmount: "due_amount",
        refundedAmount: "refunded_amount",
        refundedTaxAmount: "refunded_tax_amount",
        billingReason: "billing_reason",
        billingName: "billing_name",
        billingAddress: "billing_address",
        invoiceNumber: "invoice_number",
        isInvoiceGenerated: "is_invoice_generated",
        customerId: "customer_id",
        productId: "product_id",
        discountId: "discount_id",
        subscriptionId: "subscription_id",
        checkoutId: "checkout_id",
        customFieldData: "custom_field_data",
        platformFeeAmount: "platform_fee_amount",
        platformFeeCurrency: "platform_fee_currency",
        userId: "user_id",
      });
    }),
  );

export function orderToJSON(order: Order): string {
  return JSON.stringify(Order$outboundSchema.parse(order));
}
export function orderFromJSON(
  jsonString: string,
): SafeParseResult<Order, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Order$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Order' from JSON`,
  );
}
