/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { defaultToZeroValue } from "./defaultToZeroValue.js";
import { unrecognized } from "./unrecognized.js";

export function string(): z.ZodMiniType<string> {
  return z.union([
    z.string(),

    // Null or undefined -> ""
    zodDefaultToZeroValue(""),

    // Any other value -> String(x)
    z.pipe(z.any(), z.transform((x) => unrecognized(JSON.stringify(x)))),
  ]);
}

export function boolean(): z.ZodMiniType<boolean> {
  return z.union([
    z.boolean(),

    // String "true" (case insensitive) -> true, "false" -> false
    z.pipe(
      z.string(),
      z.transform((x, ctx) => {
        const lower = x.toLowerCase();
        if (lower === "true") return unrecognized(true);
        if (lower === "false") return unrecognized(false);
        ctx.issues.push({
          input: x,
          code: "invalid_type",
          expected: "boolean",
          received: "string",
        });
        return z.NEVER;
      }),
    ),

    zodDefaultToZeroValue(false),
  ]);
}

export function number(): z.ZodMiniType<number> {
  return z.union([
    z.number(),

    // String -> Number
    z.pipe(
      z.string(),
      z.transform((x, ctx) => {
        const num = Number(x);
        if (isNaN(num)) {
          ctx.issues.push({
            input: x,
            code: "invalid_type",
            expected: "number",
            received: "string",
          });
          return z.NEVER;
        }
        return unrecognized(num);
      }),
    ),

    // Null or undefined -> 0
    zodDefaultToZeroValue(0),
  ]);
}

export function bigint(): z.ZodMiniType<bigint> {
  return z.union([
    z.pipe(
      z.string(),
      z.transform((x, ctx) => {
        try {
          return BigInt(x);
        } catch (error) {
          ctx.issues.push({
            input: x,
            code: "invalid_type",
            expected: "bigint",
            received: "string",
          });
          return z.NEVER;
        }
      }),
    ),
    zodDefaultToZeroValue(0n),
  ]);
}

export function date(): z.ZodMiniType<Date> {
  return z.union([
    z.pipe(
      z.pipe(
        z.union([z.string(), zodDefaultToZeroValue(0)]),
        z.transform((x) => new Date(x)),
      ),
      z.date(),
    ),
    z.pipe(
      z.number(),
      z.transform((x, ctx) => {
        const date = new Date(x);
        if (isNaN(date.getTime())) {
          ctx.issues.push({
            input: x,
            code: "invalid_type",
            expected: "date",
            received: "number",
          });
          return z.NEVER;
        }
        return unrecognized(date);
      }),
    ),
  ]);
}

export function literal<T extends string | number | boolean>(
  value: T,
): z.ZodMiniType<T> {
  return z.union([z.literal(value), zodDefaultToZeroValue(value)]);
}

export function literalBigInt<T extends bigint>(value: T): z.ZodMiniType<T> {
  return z.pipe(z.literal(String(value)), z.transform((x) => BigInt(x))) as any;
}

export function optional<T extends z.ZodMiniType>(t: T) {
  return z.union([
    z.undefined(),

    // Null -> undefined
    z.pipe(z.null(), z.transform(() => unrecognized(undefined))),
    t,
  ]);
}

export function nullable<T extends z.ZodMiniType>(t: T) {
  return z.union([
    z.null(),

    // Undefined -> null
    z.pipe(z.undefined(), z.transform(() => defaultToZeroValue(null))),
    t,
  ]);
}

function zodDefaultToZeroValue<T>(value: T): z.ZodMiniType<T> {
  return z.pipe(
    z.any(),
    z.transform((input, ctx) => {
      if (input === undefined) return defaultToZeroValue(value);
      if (input === null) return defaultToZeroValue(value);
      ctx.issues.push({
        input: input,
        code: "invalid_type",
        expected: "undefined",
        received: "unknown",
      });
      return z.NEVER;
    }),
  );
}
