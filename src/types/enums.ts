/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";

declare const __brand: unique symbol;
export type Unrecognized<T> = T & { [__brand]: "unrecognized" };
export type ClosedEnum<T extends Readonly<Record<string, string | number>>> =
  T[keyof T];
export type OpenEnum<T extends Readonly<Record<string, string | number>>> =
  | T[keyof T]
  | Unrecognized<T[keyof T] extends number ? number : string>;

function unrecognized<T>(value: T): Unrecognized<T> {
  unrecognizedCount++;
  return value as Unrecognized<T>;
}

let unrecognizedCount = 0;
let refCount = 0;
export function unrecognizedCounter() {
  refCount++;
  const start = unrecognizedCount;
  return {
    count: () => {
      const count = unrecognizedCount - start;
      if (--refCount === 0) unrecognizedCount = 0;
      return count;
    },
  };
}

export function inboundSchema<T extends Record<string, string>>(
  enumObj: T,
): z.ZodMiniType<OpenEnum<T>, unknown> {
  const options = Object.values(enumObj);
  return z.union([
    ...options.map(x => z.literal(x)),
    z.pipe(z.string(), z.transform(x => unrecognized(x))),
  ] as any);
}

export function inboundSchemaInt<T extends Record<string, number | string>>(
  enumObj: T,
): z.ZodMiniType<OpenEnum<T>, unknown> {
  // For numeric enums, Object.values returns both numbers and string keys
  const options = Object.values(enumObj).filter(v => typeof v === "number");
  return z.union([
    ...options.map(x => z.literal(x)),
    z.pipe(z.int(), z.transform(x => unrecognized(x))),
  ] as any);
}

export function outboundSchema<T extends Record<string, string>>(
  _: T,
): z.ZodMiniType<string, OpenEnum<T>> {
  return z.string() as any;
}

export function outboundSchemaInt<T extends Record<string, number | string>>(
  _: T,
): z.ZodMiniType<number, OpenEnum<T>> {
  return z.int() as any;
}
